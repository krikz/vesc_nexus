# VESC_NEXUS

Универсальный драйвер для управления несколькими регуляторами VESC по CAN-шине в ROS 2.

Этот пакет предоставляет гибкое решение для работы с VESC-регуляторами, подключёнными через одну или несколько CAN-шин. Поддерживает произвольное количество интерфейсов (`can0`, `can1` и т.д.) и VESC с разными идентификаторами. Идеально подходит для роботов с танковым управлением, четырёхколёсных платформ и других систем с распределённым приводом.

## Основные возможности

- Поддержка нескольких CAN-интерфейсов
- Работа с несколькими VESC на одной шине по их ID
- Гибкая конфигурация через YAML-файлы
- Отдельные топики для команд и состояния каждого VESC
- Совместимость с ROS 2 (Humble, Iron и новее)
- Готов к интеграции с `ros2_control` и системами управления движением

## Конфигурация

Поддерживается настройка через YAML-файлы. Пример конфигурации для четырёх VESC на одной шине:

```yaml
can_interfaces:
  - name: can0
    baudrate: 500000
    vesc_ids: [1, 2, 3, 4]
publish_rate: 50.0
```

Пример для танкового шасси с двумя CAN-шинами:

```yaml
can_interfaces:
  - name: can0
    baudrate: 500000
    vesc_ids: [1, 2]   # Левая сторона
  - name: can1
    baudrate: 500000
    vesc_ids: [3, 4]   # Правая сторона
publish_rate: 50.0
```

## Топики

- `/vesc/<id>/state` — состояние регулятора (VescStateStamped)
- `/vesc/<id>/command/duty_cycle` — установка коэффициента заполнения (Float32)
- `/vesc/<id>/command/rpm` — установка целевых оборотов (Int32)

## Запуск

```bash
ros2 launch vesc_nexus vesc_nexus_node.launch.py
```

## Требования

- ROS 2 (Humble или новее)
- SocketCAN
- Пакет `vesc_nexus` (или аналогичные сообщения)
- Аппаратная поддержка CAN (например, MCP2515 или шилд для Raspberry Pi)

## Дальнейшее развитие

- Интеграция с `ros2_control`
- Поддержка traction control
- Узел для танкового управления (`tank_drive_node`)
- Диагностика состояния CAN-сети и VESC